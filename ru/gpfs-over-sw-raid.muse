#title GPFS поверх software raid

Если вы не в курсе что такое GPFS, то информация, расположенная ниже, скорее всего, является для вас
бесполезной.

* Зачем это?

В GPFS имеется ограничение на максимальное количество ре плик одного файла, равное двум. Это значит,
что при созд ании файловой системы на обычных дисках (без шареного с тораджа), при потере двух
дисков, есть ненулевая вероят ность потерять данные. При росте количества дисков, эта вероятность,
само собой, растет, что совершенно неприкольно.

Большие дядьки обычно используют для этого шареные стораджи на FC, но простым людям тоже хочется
как-то жить, не опасаясь за свои данные. В этом случае можно использовать RAID на каждой
storage-ноде GPFS.

* Проблема с BIO MD

Симптомы: при попытке создать файловую систему на NSD-ди сках, являющихся софтварным рейдом, mmcrfs
зависает навсегда.

Небольшое исследование показало следующую последовательность событий:

  1. mmcrfs выполняется несколько проверок и, если все хорошо, запускает tscrfs.
  1. tscrfs создает сокет, через msgqueue сообщает демону порт. Соединение устанавливается, tscrfs
   говорит демону "создай ФС"
  1. демон выполняет ioctl 0x1b (27) на файл /dev/ss0
  1. этот ioctl проваливается в функцию модуля mmfs ss_ioctl, затем в DiskSched::synchIO
  4. synchIO создает IOWaitQueue (cxiAllocIOWaitQueue), на которой выполняется cxiWaitIO
  5. в функции-деструкторе BIO (bioDone) написано вот что:
<pre>
  /* Ignore if bi_size is still non-zero */
  if (bioP->bi_size)
#if LINUX_KERNEL_VERSION >= 2062700
    return;
#else
    return 1;
#endif
</pre>
  Именно эта проверка и срабатывает в случае md. Для обычных блочных устройств в этом поле честный
  ноль.

Так как поле bi_size означает "сколько еще осталось байт обработать в этом BIO", то это бага
MD/DM. Буду разбираться дальше, пока есть вот такой патч, с которым GPFS начинает нормально работать
с MD-устройствами. Строго говоря, патч не совсем корректен, но как временное решение сойдет:

<pre>
diff -Nru src.orig/gpl-linux/cxiIOBuffer.c src/gpl-linux/cxiIOBuffer.c
--- src.orig/gpl-linux/cxiIOBuffer.c    2009-09-04 14:39:34.000000000 +0400
+++ src/gpl-linux/cxiIOBuffer.c 2009-09-04 14:39:43.000000000 +0400
@@ -1570,14 +1570,6 @@
 {
   struct cxiBufHeadChunk_t* bhcHeadP;

-  /* Ignore if bi_size is still non-zero */
-  if (bioP->bi_size)
-#if LINUX_KERNEL_VERSION >= 2062700
-    return;
-#else
-    return 1;
-#endif
-
   bhcHeadP = (struct cxiBufHeadChunk_t*)bioP->bi_private;
   /* Decrement number of outstanding bios */
   /* If this is the last bio in the chunk list, enqueue the chunk list
</pre>
